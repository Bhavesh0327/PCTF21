# Writeup
We are given a binary which prints an encrypted flag by reading the flag from 'flag.txt', and we are asked to decrypt it.
```
$ ./revme
Here is your flag.
Encrypted Flag: JcOCLQgPJEjwNAZHgVFzAoMVHOiCRVAVKkvFidUvzmUSSnqJzO
```
GDB disassembly of main shows something different - there seem to be mangled symbols [characteristic of Rust](https://en.wikipedia.org/wiki/Name_mangling#Rust).
```
(gdb) disas main
Dump of assembler code for function main:
   0x0000000000009d30 <+0>:     push   rax
   0x0000000000009d31 <+1>:     movsxd rax,edi
   0x0000000000009d34 <+4>:     lea    rdi,[rip+0xfffffffffffffdd5]        # 0x9b10 <_ZN5revme4main17h7ab14d9495e9ec88E>
   0x0000000000009d3b <+11>:    mov    QWORD PTR [rsp],rsi
   0x0000000000009d3f <+15>:    mov    rsi,rax
   0x0000000000009d42 <+18>:    mov    rdx,QWORD PTR [rsp]
   0x0000000000009d46 <+22>:    call   0xbc00 <_ZN3std2rt10lang_start17hc9a16391b7c2a43fE>
   0x0000000000009d4b <+27>:    pop    rcx
   0x0000000000009d4c <+28>:    ret
End of assembler dump.
```
This [script](https://github.com/daniellimws/ghidra_scripts/blob/master/rust_demangler.py) is very helpful for making the function names more readable in Ghidra.
First, we locate `main` and look at its decompilation. Variables have been re-named for convenience. It seems to call a function to read a string from a file, read another string from memory `0x13d134` with length `0x12`, and passes these to an `encrypt`function, and finally prints the encrypted output.
We can recover the string from memory as `EWeVslAFgqhBaugWvU`.
This is probably used as a key for encryption.
```c

/* WARNING: Could not reconcile some variable overlaps */
/* revme::main::h7ab14d9495e9ec88 */

void revme::main::h7ab14d9495e9ec88(void)

{
  undefined8 in_R9;
  undefined4 str_read_from_file;
  undefined4 uStack276;
  undefined4 uStack272;
  undefined4 uStack268;
  undefined8 local_108;
  undefined4 key_from_mem;
  undefined4 uStack252;
  undefined4 uStack248;
  undefined4 uStack244;
  undefined8 local_f0;
  undefined local_e8 [48];
  undefined local_b8 [48];
  undefined local_88 [16];
  undefined *local_78;
  undefined enc_flag [24];
  undefined4 plain_flag;
  undefined4 uStack84;
  undefined4 uStack80;
  undefined4 uStack76;
  undefined8 local_48;
  undefined4 key;
  undefined4 uStack52;
  undefined4 uStack48;
  undefined4 uStack44;
  undefined8 local_28;
  undefined local_12;
  undefined local_11;
  
  local_12 = 0;
  local_11 = 1;
  revme::read_string_from_file::h2e996ce9583a8f3c(&str_read_from_file,0x13d12c,8);
  _<alloc::string::String_as_core::convert::From<$RF$str>>::from::hbdb9ecbef712c5a0
            (&key_from_mem,0x13d134,0x12);
  local_12 = 1;
  core::fmt::Arguments::new_v1::h1c266a6aed41cf13(local_e8,&DAT_0014d458,1,"Encrypted Flag: \n",0);
  _print(local_e8);
  local_11 = 0;
  local_48 = local_108;
  plain_flag = str_read_from_file;
  uStack84 = uStack276;
  uStack80 = uStack272;
  uStack76 = uStack268;
  local_12 = 0;
  local_28 = local_f0;
  key = key_from_mem;
  uStack52 = uStack252;
  uStack48 = uStack248;
  uStack44 = uStack244;
  revme::encrypt::hb3ce30f62a454b11(enc_flag,&plain_flag,&key);
  local_78 = enc_flag;
  local_88 = core::fmt::ArgumentV1::new::hcdff391bb8e2919c
                       (local_78,
                        _<alloc::string::String_as_core::fmt::Display>::fmt::heff6dbb7e402187d);
  core::fmt::Arguments::new_v1::h1c266a6aed41cf13
            (local_b8,&PTR_s_Encrypted_Flag:_0014d468,2,local_88,1,in_R9,local_88);
  _print(local_b8);
  core::ptr::drop_in_place::h991b4fdb2b7efe93(enc_flag);
  return;
}
```
Now we look at the `encrypt`function. There seems to be an index into the key string which gets updated as `(index + 1) % keylen`, so it must keep going through the key string cyclically. With further inspection, we can see that it is a substitution cipher similar to the [Vigenère cipher](https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher).
```c
/* WARNING: Could not reconcile some variable overlaps */
/* revme::encrypt::hb3ce30f62a454b11 */

undefined8
revme::encrypt::hb3ce30f62a454b11(undefined8 encrypted_flag,undefined8 plain_flag,undefined8 key) {
  byte bVar1;
  ulong key_len;
  ulong extraout_RDX;
  ulong uVar2;
  ulong cyclic_key_index;
  bool bVar3;
  undefined auVar4 [16];
  ulong key_index;
  undefined local_30 [20];
  int local_1c;
  int local_18;
  byte local_13;
  byte A_or_a_1;
  byte A_or_a_2;
  
  key_len = alloc::string::String::len::h50b91dbaaddac41a(key);
  key_index = 0;
  alloc::string::String::new::ha2c86691dc399d67(encrypted_flag);
  auVar4 = _<alloc::string::String_as_core::ops::deref::Deref>::deref::hc2d058c89e719ed7(plain_flag)
  ;
  auVar4 = core::str::_<impl_str>::chars::hb431bb31845adbeb
                     (SUB168(auVar4,0),SUB168(auVar4 >> 0x40,0));
  local_30._0_16_ =
       _<I_as_core::iter::traits::collect::IntoIterator>::into_iter::h5032c68670a6906d
                 (SUB168(auVar4,0),SUB168(auVar4 >> 0x40,0));
  while( true ) {
    do {
      local_1c = 
                 _<core::str::iter::Chars_as_core::iter::traits::iterator::Iterator>::next::ha056855b24335149
                           (local_30);
      uVar2 = (ulong)(local_1c != 0x110000);
      if (local_1c == 0x110000) {
        core::ptr::drop_in_place::h991b4fdb2b7efe93
                  (key,uVar2,extraout_RDX & 0xffffffffffffff00 | uVar2);
        core::ptr::drop_in_place::h991b4fdb2b7efe93(plain_flag);
        return encrypted_flag;
      }
      local_18 = local_1c;
      bVar1 = core::char::methods::_<impl_char>::is_ascii_alphabetic::h03848815b83841c0(&local_18);
    } while ((bVar1 & 1) == 0);
    auVar4 = alloc::string::String::as_bytes::h4d166d0f87f42768(key);
    uVar2 = SUB168(auVar4 >> 0x40,0);
    if (key_len == 0) break;
    cyclic_key_index = key_index % key_len;
    if (uVar2 <= cyclic_key_index) {
      panic_bounds_check(cyclic_key_index,uVar2,&PTR_s_./revme.rs_0014d358);
      goto LAB_001096aa;
    }
    local_13 = *(byte *)(SUB168(auVar4,0) + cyclic_key_index);
    bVar1 = core::char::methods::_<impl_char>::is_ascii_lowercase::h4a13849f74b606b1(&local_18);
    if ((bVar1 & 1) == 0) {
      A_or_a_1 = 0x41;
    }
    else {
      A_or_a_1 = 0x61;
    }
    bVar1 = core::num::_<impl_u8>::is_ascii_lowercase::hc5f7bdd0511ee156();
    if ((bVar1 & 1) == 0) {
      A_or_a_2 = 0x41;
    }
    else {
      A_or_a_2 = 0x61;
    }
    if (local_13 < A_or_a_2) {
      panic("attempt to subtract with overflow",0x21,&PTR_s_./revme.rs_0014d370);
      goto LAB_001096aa;
    }
    bVar3 = 0xfffffffffffffffe < key_index;
    key_index = key_index + 1;
    if (bVar3) {
      panic(
            "attempt to add with overflowfailed to open : failed to readflag.txtEWeVslAFgqhBaugWvUHere is your flag.\n"
            ,0x1c,&PTR_s_./revme.rs_0014d388);
      goto LAB_001096aa;
    }
    bVar1 = (byte)local_18 + (local_13 - A_or_a_2);
    if (CARRY1((byte)local_18,local_13 - A_or_a_2) != false) {
      panic(
            "attempt to add with overflowfailed to open : failed to readflag.txtEWeVslAFgqhBaugWvUHere is your flag.\n"
            ,0x1c,&PTR_s_./revme.rs_0014d3a0);
      goto LAB_001096aa;
    }
    if (bVar1 < A_or_a_1) {
      panic("attempt to subtract with overflow",0x21,&PTR_s_./revme.rs_0014d3b8);
      goto LAB_001096aa;
    }
    if (CARRY1(A_or_a_1,(bVar1 - A_or_a_1) % 0x1a) != false) {
      panic(
            "attempt to add with overflowfailed to open : failed to readflag.txtEWeVslAFgqhBaugWvUHere is your flag.\n"
            ,0x1c,&PTR_s_./revme.rs_0014d3d0);
      goto LAB_001096aa;
    }
    alloc::string::String::push::h8ec1d44b8692ba76(encrypted_flag);
  }
  panic("attempt to calculate the remainder with a divisor of zero",0x39,&PTR_s_./revme.rs_0014d340)
  ;
LAB_001096aa:
  do {
    invalidInstructionException();
  } while( true );
}
```

With this information, we can write a script to get our flag.
```python
from pwn import *

binary = './revme'
# context.log_level='debug'
elf = ELF(binary)


def cyclic_key(key, size):
    key_len = len(key)
    for i in range(size - key_len):
        key += key[i % key_len]
    return key


def decrypt(enc_flag, cyclic_key):
    flag = ""
    for i in range(len(enc_flag)):
        if enc_flag[i] >= 'a':
            flag_a = 'a'
        else:
            flag_a = 'A'

        if cyclic_key[i] >= 'a':
            key_a = 'a'
        else:
            key_a = 'A'

        enc_flag_char = ord(enc_flag[i]) - ord(flag_a)
        key_char = ord(cyclic_key[i]) - ord(key_a)

        flag += chr((enc_flag_char - key_char + 26) % 26 + ord(flag_a))
    return flag


p = process(binary)
p.recvuntil('Flag: ')
enc_flag = p.recvuntil('\n').decode().strip('\n')
key = "EWeVslAFgqhBaugWvU"
cyc_key = cyclic_key(key, len(enc_flag))
print("pctf{" + decrypt(enc_flag, cyc_key) + "}")
```
Running it, we get the flag as:
```
[*] '/ctf/revme'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Starting local process './revme': pid 40266
[*] Process './revme' stopped with exit code 0 (pid 40266)
pctf{FgKHTFgKDOcvNGTLlBBdWtUKHJcMKUABEoaLehQahbUNMxjIzU}
```
